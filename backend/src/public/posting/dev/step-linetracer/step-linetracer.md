---
title: "낮은 레벨에서 배우는 높은 가치: STEP 라인트레이서가 가져다준 통찰"
date: 2024-01-07 19:34
tag: [embedded]
category: dev
---

## 0. 목차

1. 들어가며
2. STEP 라인트레이서 소개
3. 모듈화의 중요성
4. 성능 향상을 위한 방법 테스트
5. State Machine과 비동기 함수
   - 5-1. State Machine이란?
   - 5-2. STEP 라인트레이서 개발에서 학습했던 State Machine
   - 5-3. State Machine과 javascript의 비동기 함수
6. 나오며

## 1. 들어가며

이번 글은 STEP 모터를 활용한 라인트레이서를 중심으로 진행됩니다. 첫째로 STEP 라인트레이서를 간단히 설명해볼까 합니다. 둘째로 라인트레이서 제작에서 느낀 모듈화의 중요성을 논해볼까 합니다. 셋째로 성능 향상을 위하여 여러 방법을 테스트하며 얻었던 인사이트에 대해서 이야기해보겠습니다. 마지막으로 임베디드 소프트웨어를 학습하며 익혔던 State Machine을 javascript의 비동기 함수의 내부구현과 엮어보며 낮은 레벨과 높은 레벨을 넘나들어보겠습니다. (노파심이겠지만, 낮은 레벨과 높은 레벨이 의미하는 바는 "평가가 낮다"를 의미하는게 아니라 컴퓨터(하드웨어)와 얼마나 가까운지 여부를 의미합니다.)

## 2. STEP 라인트레이서 소개

라인트레이서는 검은색 배경에 흰색선이 배치된 맵에서 흰색선을 따라가는 로봇입니다. 라인트레이서 대회의 규정은 대체로 어떤 로봇이 완주를 빨리하느냐로 초점이 맞춰져 있습니다. 로봇이 동작하는 대회 영상은 [유튜브 링크](https://youtube.com/@zerotoinfinite2418?feature=shared)를 통하여 확인해볼 수 있습니다. 더하여 여러 주행전략을 통하여 기록을 개선할 수 있습니다. 예를들어, 첫번째 주행에서 직선의 정보를 저장해둔뒤, 직선에서는 가속을 진행하는 것이 예시가 되겠습니다.

이때 구체적인 구현은 어떻게 이루어질까요? 먼저 라인트레이서의 구성 요소에 대해 살펴봅시다. 크게는 회로, 소프트웨어, MCU, 모터, 배터리 등으로 나눌 수 있습니다.

먼저 MCU, 모터와 배터리를 살펴보겠습니다. MCU는 STM32F411을 사용하였습니다. 모터는 STEP 모터를 배터리는 12cell 44.4v의 배터리를 활용하였습니다. STEP 모터는 저렴하고 제어가 비교적 쉽다는 장점이 있습니다.(카메라 렌즈의 stm 모터가 STEP 모터를 사용합니다.) 더하여 배터리는 모터 드라이버의 데이터시트에 기초하여, 모터 드라이버가 버틸 수 있는 최대 전압을 고려하였습니다.

다음으로 회로 구성에 대해 살펴보겠습니다. 회로는 파워, 센서 보드, 센서 신호, 모터 드라이버, 모터 신호 등으로 나눌 수 있습니다.

파워는 배터리에서 나온 전압을 보드가 사용할 수 있는 전압으로 낮추는 데에 초점이 맞춰져 있습니다. 배터리는 12셀을 활용하는데, 이는 약 44.4v에 해당합니다. 이런 전압을 보드에 직접 인가하면 보드는 사용할 수 없게 됩니다. 따라서 약 44.4v를 5v 혹은 3.3v로 바꾸는 것이 파워의 역할입니다.

센서는 흰색과 검은색을 구분하기 위하여 8개의 IR 센서를 활용하며, 센서 보드는 8개의 IR 센서를 달아둔 보드를 의미합니다. IR 센서는 아날로그 신호를 전달합니다. 하지만 아날로그 신호를 가공하기는 어려움으로, 이를 디지털 신호로 바꿀 필요가 있습니다. 그런데 아날로그 신호를 디지털 신호로 변환하는데에는 ADC가 필요합니다. 이때 STM f411 보드에는 ADC가 1개 밖에 없기 때문에, 8개의 센서의 아날로그 신호를 한번에 디지털 신호로 전환할 수 없습니다. 이에 MUX라는 소자를 활용하여 8개의 센서를 하나씩 차례로 ADC와 연결하여, 8개의 아날로그 신호를 차례로 디지털 신호로 전환합니다.

모터는 모터 드라이버를 이용하여 제어합니다. 모터 드라이버는 적절한 신호를 통해 제어됩니다. 모터 신호와 관련한 회로는 pull-down을 통하여 floating을 방지하여야 합니다. 이때 floating에 대해 설명해보겠습니다. 모터 드라이버는 0v는 0으로 5v는 1로 해석한다고 가정합시다. 이때 신호선에 pull-down을 해주면 신호선의 기본 전압은 0v가 됩니다. 하지만 pull-down을 하지 않는다면 2.1v, 3.5v 등의 0v 이상의 전압이 기본 상태가 될 수 있으며, 이는 신호를 안정적으로 제어하기 어렵게 하는 원인입니다. 이처럼 모터와 관련한 회로는 모터 드라이버에 안정적으로 신호를 전달하는 역할을 합니다. 더하여 모터 드라이버는 전달된 신호에 기반하여, 약 44.4v의 전압으로 모터를 제어합니다.

마지막으로 소프트웨어 구성에 대해 살펴보겠습니다. 소프트웨어는 정말 간단하게 센서, 모터, 조향, 주행전략 부분으로 나눌 수 있습니다. 특히 센서, 모터, 조향은 Timer interrupt를 활용하여 특정 주기마다 실행됩니다. 센서는 MUX를 제어하고 ADC 값을 읽어온 후, 값을 바탕으로 로봇의 위치를 추정하는 등의 역할을 합니다. 조향은 이렇게 추정된 위치를 바탕으로 왼쪽 모터와 오른쪽 모터의 속도를 결정하는 역할을 합니다. 모터와 관련된 코드는 한번 호출되면 STEP 모터의 1/400(혹은 정해진 다른 각도)을 돌립니다. 특히 모터 코드는 결정된 속도를 바탕으로 호출되는 주기가 변화하며, 속도가 빠르면 빠르게, 속도가 느리면 느리게 호출됩니다. 그리고 주행 전략 부분은 라인트레이서가 지금 직선에서 가속을 해야하는지, 혹은 경기가 끝나서 멈춰야하는지 등을 결정합니다.

지금까지 구체적인 구현을 살펴보며 관련한 지식을 살펴보았습니다. 구현을 정말 간략히 설명했기에 중간중간 빠진 부분이 많지만, 핵심을 최대한 짚으려 노력했습니다. 지금부터는 이렇게 각 구성요소를 나누어서 얻었던 이점에 대해 살펴보며, 모듈화에 대한 저의 생각에 대해 이야기해보겠습니다.

## 3. 모듈화의 중요성

라인트레이서는 각 구성요소가 나누어져있습니다. 이런걸 모듈화라고 하겠지요. 그런데 모듈화를 하게된다면 어떤 이점이 있을까요? STEP 라인트레이서를 제작하며 제가 느꼈던 모듈화의 이점인 디버깅이 쉬워진다는 것을 살펴보겠습니다.

라인트레이서를 제작하는 사람은 수많은 문제에 직면할 것 입니다. 제가 겪었던 문제상황 중 하나를 예시로 들어볼까 합니다. 전날까지는 멀쩡히 정상적으로 구동하던 라인트레이서가 갑자기 센서값을 읽어오지 못하는 문제가 있었습니다. 이제 문제의 원인을 찾고 해결해야할 것 입니다.

그런데 임베디드 개발의 디버깅은 높은 레벨 개발의 디버깅과는 조금 차이가 있습니다. 대부분의 경우 높은 레벨에서는 콜스택이 명확이 에러 메세지에 표출되며, 문제지점을 정확히 찾을 수 있습니다. 프로그램이 문제지점을 찾아주고 개발자는 단순히 문제지점의 코드를 수정하면 됩니다. 그런데 임베디드 개발은 그렇지 않습니다. 문제지점을 찾기가 정말 어렵습니다. 회로에 문제가 있을 수도 있고, 센서 자체에 문제가 있을 수도 있으며, 코드를 수정하여 문제가 발생한 것일 수도 있습니다. 이러한 상황에서 저는 문제지점을 찾기 위하여, 문제의 여집합을 찾아나가는 방향으로 디버깅을 진행합니다.

예를들어 보겠습니다. 가장 쉬운 방법인, 기존 코드를 정상작동한 코드로 교체해봅니다. 기존 코드가 정상이라면, 문제의 가능성이 제일 높은 센서를 교체하여, 센서가 정상인지 판단합니다. 이렇게 나름의 우선순위를 정하고 정상인 것의 범주를 명확히 파악해보고는 합니다. 즉, 정상 파츠와 교체해보며, 문제 발생 부분의 여집합을 확장시켜 나갑니다. 그리고 센서가 먹통이 된 원인이 단선된 센서 연결 케이블에 있었다는 것을 알아내고 허탈함에 헛웃음을 짓곤 했었습니다. 여기에서 모듈화의 이점이 드러납니다. 정상의 범위를 확장해나가고, 문제 지점을 명확히 찾아 나가기 위해서는, 정상 파츠와 교체해보는 과정이 필요했었습니다. 이처럼 모듈화는 디버깅에 이점을 가집니다.

사실 문제지점을 명확히 할 수 없는 경우는 높은 레벨의 개발에서도 심심치 않게 찾아볼 수 있겠습니다. 예를들어 "웹사이트의 성능이 문제인데 어떻게 향상시킬 것인가?" 등이 있겠네요. 제가 이런 문제에 당면했을때 임베디드 개발에서 겪었던 디버깅 경험이 유용하게 작용했던 것 같습니다.

## 4. 성능 향상을 위한 방법 테스트

라인트레이서의 성능의 척도는 무엇일까요? 바로 "얼마나 빠르게 주행할 수 있는가?" 일 것입니다. 그런데 어떻게 속도를 향상시킬 수 있을까요? 이에 대해 매우 많은 시도와 시행착오를 겪었습니다.

하나의 예를 들어보겠습니다.먼저 STEP 모터는 속도 변화에 취약합니다. 가속도를 너무 높이면, STEP 모터는 제어 불능 상태에 빠지게 되는 치명적인 상황에 도달할 수 있습니다. 이에 저는 STEP 모터의 제어방식에 주목하였습니다. 즉, 모터 제어 방식을 변화시킴으로써 가속도를 높여도 안정적으로 동작하게끔 만드는 것을 목표로 하였습니다.

기존 동아리에서 STEP 모터를 제어하는 방식은 1-2상 여자제어방식이었습니다. 제가 고려한 방식은 2상 여자제어방식입니다. 2상 여자제어방식은 타 방식에 비해 안정적으로 모터를 구동시킬 수 있으나, 소비전력이 높은 단점을 지닙니다. 하지만 저의 라인트레이서 프로젝트에서는 소비전력이 높더라도 안정적으로 제어하는 것이 유리하다고 판단하여, 모터의 구동방식을 2상 여자제어방식으로 전환해보았습니다.

이때 기존의 방식과 새로운 방식에 대한 성능평가는 어떻게 진행해야할까요? 동일한 맵을 주행하며 기록한 시간을 측정하는 방법이 있을 것입니다. 하지만 맵에 묻어있는 먼지, 배터리의 전압 등 여러 변수가 일정하지 않은 상태에서 주행기록은 성능측정의 요소로 쓰이기 어려웠습니다. 실제로 기존의 방식과 새로운 방식은 그 결과가 들쭉날쭉하게 측정되었습니다. 이러한 경험을 통하여 성능평가에서 다른 변수를 고정하는 것의 중요성을 깨달았습니다.

더하여 기존의 방식과 새로운 방식을 테스트할 때, 주석을 통하여 방식을 전환하였습니다. 아래 예시를 첨부하겠습니다.

- config.h

```c
/* 생략 */

// 2상 여자제어방식
//#define SPEED_COEF  ( 31415.92f * TIRE_RADIUS )

// 1-2상 여자제어방식
#define SPEED_COEF  ( 15707.96f * TIRE_RADIUS )

// 2상 여자제어방식
//#define TICK_PER_M  ( 31.831f / TIRE_RADIUS )

// 1-2상 여자제어방식
#define TICK_PER_M  ( 63.662f / TIRE_RADIUS )

/* 생략 */
```

- motor.c

```c
/* 생략 */

// 2상 여자제어방식
//extern uint8_t  phaseL_table[4];
//extern uint8_t  phaseR_table[4];

// 1-2상 여자제어방식
extern uint8_t  phaseL_table[8];
extern uint8_t  phaseR_table[8];

/* 생략 */
```

이렇게 여러 파일에 걸쳐 주석을 바꾸어가며 방식을 변경시키는 것은, 굉장히 비효율적이고 개발자의 실수를 일으킬 수 있다고 생각합니다. 이러한 고민을 품은채로 다른 개발을 진행하다 좋은 해결책을 하나 발견하여 소개해볼까 합니다. 이 코드에서 문제점은 한 파일에 1-2상 여자제어방식과 2상 여자제어방식이라는 각기 다른 두개의 로직을 담고 있다는 것에 기인합니다. 따라서 지금 코드를 짠다면 저는 파일을 분리하고 의존성을 주입하는 형태로 구성할 것입니다.

- motor-v1.h

```c
// 1-2상 여자제어방식
#define SPEED_COEF  ( 15707.96f * TIRE_RADIUS )
#define TICK_PER_M  ( 63.662f / TIRE_RADIUS )

uint8_t             phaseL_table[8];
uint8_t             phaseR_table[8];

/* 1-2상 여자제어방식 모터 제어 함수를 export */
```

- motor-v2.h

```c
// 2상 여자제어방식
#define SPEED_COEF  ( 31415.92f * TIRE_RADIUS )
#define TICK_PER_M  ( 31.831f / TIRE_RADIUS )

uint8_t             phaseL_table[4];
uint8_t             phaseR_table[4];

/* 2상 여자제어방식 모터 제어 함수를 export */
```

- main.c

```c
#include "motor-v1.h"
// #include "motor-v2.h"
```

이런식으로 한 파일에 여러 로직을 담는 것이 아닌, 파일을 분리하는 것이 더 나은 설계라고 생각합니다. 즉, 기존에는 테스트를 하기 위하여, 여러 파일을 찾아다니며 여러 주석을 변경해야했지만, 개선 후에는 main.c의 주석 한줄만을 변경하면 됩니다. (의존성 주입 만세! 클린 아키텍쳐 만세!)

여담으로 1-2상여자 제어와 2상여자 제어 중에 어떤 방식을 채택했냐하면, 성능 차이가 별로 없어 보여서 1-2상여자 제어 방식을 선택했습니다. 결국 레거시를 선택한 것이죠. 그렇다면 이런 노력은 의미가 없는 것일까요? 아닙니다. 1-2상여자 제어에서 2상여자 제어로 변경하니, 제어 주기가 늘어남에 따라 모터의 구동음이 기존보다 낮은 소리로 들렸습니다. 그리고 제어 주기가 달라짐에 따라 소리의 음이 변화했던 경험을 바탕으로, 추후 DC 모터를 활용한 라인트레이서에서 치명적인 문제를 해결할 수 있었습니다. 정말 쓸데 없는 경험처럼 보이지만 이런 사소한 경험이 도움이 되는 경우도 있더군요. DC 라인트레이서와 관련한 문제해결 경험은 다음 포스팅에서 다뤄볼 예정입니다.

지금까지 라인트레이서의 성능을 향상하기 위한 노력들과, 성능 평가에 대한 저의 인사이트를 공유해보았습니다. 지금부터는 State Machine을 살펴보고, State Machine으로 javascript의 비동기 함수를 더욱 깊게 이해해보겠습니다.

## 5. State Machine과 비동기 함수

이번 소주제에서는 STEP 라인트레이서를 제작하며 활용한 State Machine을 살펴보려합니다. 더하여 3명의 호기심으로 시작한, javascript 비동기 함수의 내부 구현을 뜯어본 경험을 소개하겠습니다. 임베디드 소프트웨어에서 학습했던 State Machine이, javascript 비동기 함수의 이해를 도왔다는 점을 짚는 것을 마지막으로 소주제를 마치려 합니다.

> ### 5-1. State Machine이란?

본론에 앞서 State Machine에 대한 간단한 설명이 필요할 것 같습니다. State Machine은 상태를 관리하는 하나의 설계 방식입니다. 그런데 상태 관리란 정확히 무엇을 의미할까요? 예를 들어보겠습니다. 저는 지금 퇴근길에 있다고 가정해보겠습니다. 회사에서 집까지는 하나의 횡단보도가 있습니다. 그렇다면 저의 퇴근길은 다음의 상태들로 나타내볼 수 있을 것입니다.

1. 퇴근시간까지 회사에서 대기 상태(IDLE)
   - 퇴근시간이 되면 다음 상태로 넘어감
2. 횡단보도로 이동하는 상태
   - 횡단보도에 도착하면 다음 상태로 넘어감
3. 초록불을 대기하는 상태
   - 초록불이 되면 다음 상태로 넘어감
4. 집으로 이동하는 상태
   - 집에 도착하면, 다음날 다시 회사에 가서 퇴근시간까지 기다림(IDLE 상태로 돌아감)

예시에서 각 상태는 어떤 조건이 충족되면 다음단계로 넘어갑니다. 이렇게 행위를 단계별로 나눈뒤 상태를 관리하는 것이 State Machine의 주요 개념입니다. 그렇다면 이렇게 상태를 관리하는 것은 어떤 이점을 불러올까요? 여러 이점이 있지만, 이번 글에서는 '에러 처리', '비동기 처리'와 관련한 이점 대해 다뤄볼까 합니다.

먼저 '에러 처리'와 관련한 이점에 대해 살펴봅시다. 저는 횡단보도로 이동하는 상태에 있었습니다. 그런데 갑자기 상사가 "내가 매우 적적하네"라고 말하며 회사로 복귀하라 하네요? 이건 에러죠... State Machine과 함께라면 저는 회사로 복귀하는 상황을 더욱 자세히 로깅할 수 있습니다. 예를들어 "횡단보도로 이동하다가 상사가 회사로 부름" 이런식으로 말이죠. 단순히 "상사가 회사로 부름"으로 로깅을 하기보다는, 어느 상태에서 에러가 났다고 로깅하는 것은 추후 에러를 다루는데에 있어 중요한 요소일 것입니다. 이처럼 State Machine은 에러 기록 및 에러 처리에 용이한 역할을 할 수 있습니다.

다음으로 '비동기 처리'와 관련한 이점 대해 알아봅시다. 먼저 State Machine을 활용하지 않는다고 가정해봅시다. 저는 초록불을 기다리고 있었습니다. 그런데 저는 기다리는 시간이 너무 아까운 나머지 핸드폰을 보고싶습니다. 그런데 핸드폰을 본 순간 저는 상태를 기억하지 않았기 때문에 초록불을 기다리고 있던 것을 까먹습니다. 따라서 퇴근 시간이 지났는지, 횡단보도에 도착했는지를 순차적으로 확인하고 나서야 지금 내가 초록불을 대기하는 상태인 것을 인지하게 됩니다. 즉, 불필요한 과정이 너무나 많이 생깁니다. 한편, 이러한 불필요한 과정을 줄이기 위하여 저는 초록불 기다리는 상태에 온 순간, 다른 활동은 전부 멈추고 초록불이 되기를 하염없이 기다리는 방법을 택할 수도 있을 것 입니다. 그러나 이 방법을 택하면 핸드폰을 못하게 되며 시간을 허비하게 됩니다. 이러한 비효율을 막기 위하여 State Machine을 이용합니다. 마찬가지로 저는 초록불을 대기하는 상태에 있었습니다. 저는 초록불을 기다리는 동안 핸드폰으로 다른 작업을 합니다. 그리고 내가 초록불을 기다리고 있는 상태라는 것을 기억합니다. 이렇게 하면 핸드폰을 보면서, 기억한 상태를 기초로 중간중간 초록불이 됐는지 확인할 수 있습니다. 이처럼 저는 핸드폰을 하며, 초록불을 대기하는 2개의 작업을 효율적으로 함께 처리할 수 있습니다. 즉, a와 b라는 작업을 둘 다 수행해야할 필요가 있을 때, 상태를 기억함으로써, 불필요한 연산을 최소화할 수 있습니다.

- State Machine 활용 시 => 2개의 작업을 효율적으로 함께 처리 가능

  1. 초록불인지 확인
  2. 핸드폰을 봄
  3. 초록불인지 확인
  4. 핸드폰을 봄

- 상태 저장을 안했을 시 => 비효율적

  1. 퇴근시간인지 확인(필요없는 연산)
  2. 횡단보도에 도착했는지 확인(필요없는 연산)
  3. 초록불인지 확인
  4. 핸드폰을 봄

- while문으로 block 시 => 2개의 작업을 함께 처리 불가능

  1. 초록불로 바뀔 때까지 대기
  2. 핸드폰을 봄

지금까지 State Machine의 개념과 사용하였을 때 기대할 수 있는 효과에 대해 살펴보았습니다. 간단히 요약하면, State Machine은 상태를 관리하기 위한 설계방식 중 하나입니다. 더하여 State Machine을 활용했을때 에러 처리, 비동기 처리 측면에서 이점을 기대해볼 수 있습니다. 지금부터는 임베디드 소프트웨어를 배우며 경험한 State Machine과, 이를 밑바탕으로 javascript의 비동기를 심도있게 이해한 경험을 소개해볼까 합니다.

> ### 5-2. STEP 라인트레이서 개발에서 학습했던 State Machine

다른 개발과 비교하면, 임베디드 소프트웨어 개발은 불필요한 연산을 줄이는 최적화가 필요합니다. 더하여 라인트레이서의 경우 로봇의 상태를 파악함과 동시에 주행 전략을 선택하는 등의 여러 작업을 함께 처리해야 합니다. 또한 대부분의 임베디드 소프트웨어는 싱글 스레드 환경에서 동작합니다.

이러한 특징으로 인하여 STEP 라인트레이서 제작에서는 여러 작업을 효율적으로 처리하기 위하여 State Machine을 활용합니다. 먼저 저의 라인트레이서는 기록 단축을 위하여 직선에서 가속을 할 수 있도록 설계하였습니다. 이때 직선에서 가속하는 작업을 함과 동시에, 마크를 판단한다던지, 로봇에 이상이 없는지 등의 작업을 함께 처리하는 것이 필요한 상황이었습니다. 이에 직선에서 가속하는 작업을 직선에서 가속을 기다리는 상태, 감속을 기다리는 상태, 직선 가속이 종료된 상태 등으로 나눈 후 State Machine으로 설계하였습니다. 다음은 제가 STEP 라인트레이서를 제작하며 작성한 코드를 재구성한 것입니다.

```c
void Straight_Boost() {
    static uint8_t starightBoostCntl = BOOST_CNTL_IDLE;

	// 직선 가속 시퀀스
	switch (starightBoostCntl) {

        // IDLE, 가속 시퀀스 진입 대기 상태
        // 가속 시퀀스 진입 조건을 충족했다면 가속 시작
        case BOOST_CNTL_IDLE :
            if (가속 시퀀스 진입 여부 판단) {
                /* 생략 */
                starightBoostCntl = BOOST_CNTL_DECELE;
            }
            break ;

        // 감속 시작을 기다리는 상태
        // 감속 지점에 도달하였다면 감속 시작
        case BOOST_CNTL_DECELE :
            if (감속 지점에 도달 여부 판단) {
                /* 생략 */
                starightBoostCntl = BOOST_CNTL_END;
            }
            break ;

        // 직선 가속 시퀀스 종료 여부를 기다리는 상태
        // 직선 가속 시퀀스가 종료되었다면 IDLE 상태로 돌아감
        case BOOST_CNTL_END :
            if (직선 가속 시퀀스 종료 여부 판단) {
                /* 생략 */
                starightBoostCntl = BOOST_CNTL_IDLE;
            }
            break ;
	}
}
```

실제 구현은 아래와는 매우 상이하지만, 위의 Straight_Boost()라는 함수는 main 문에서 다음과 같이 호출된다고 이해해도 좋습니다.

```c
int main(void) {
    while(1) {
        Judge_Mark(); // 마크를 판단하는 함수 => State Machine으로 설계함
        Is_Robot_Ok(); // 로봇의 정상 여부 탐지 함수 => State Machine으로 설계함
        Straight_Boost();
    }
}
```

이때 마크를 판단하는 함수, 로봇 이상 탐지 함수 또한 State Machine으로 구현되어 있습니다. 즉, Straight_Boost()라는 함수는 Judge_Mark()와 Is_Robot_Ok()라는 함수의 작업과 함께 실행될 수 있습니다. 이때 상태를 저장해둠으로써, 감속 여부를 판단할 때에, 가속 여부를 판단하는 등의 비효율적인 동작을 최소화할 수 있습니다. 로봇이 직선 가속 종료 중인 상황임을 가정했을때, State Machine 활용 여부로 인하여 달라지는 작업량을 아래에 제시하겠습니다.

- 상태 저장을 안했을 때의 작업량

  1. Judge_Mark() 실행
  2. Is_Robot_Ok() 실행
  3. 가속 시퀀스 진입 여부 판단(필요 없는 연산)
  4. 감속 지점에 도달 여부 판단(필요 없는 연산)
  5. 직선 가속 시퀀스 종료 여부 판단(필요한 연산)

- State Machine 활용 시 작업량

  1. Judge_Mark() 실행
  2. Is_Robot_Ok() 실행
  3. 직선 가속 시퀀스 종료 여부 판단

이러한 State Machine의 개념을 라인트레이서를 만들며 동아리 선배님들을 통하여 학습할 수 있었습니다. State Machine에 대한 이해는 추후 javascript의 비동기를 심도있게 이해하는 것에 도움을 주었습니다.

> ### 5-3. State Machine과 javascript의 비동기 함수

우리는 async, await에 대하여 학습할때, 비동기적으로 동작하며 다른 작업과 함께 처리될 수 있다는 것을 학습합니다. 조금 더 깊게 들어가면 call stack, task queue와 연관지어 살펴보기도 합니다. 저 또한 이 정도의 지식을 학습하였고, 비동기 함수의 개념을 추상적으로만 이해하고 있었습니다. 그런데 바야흐로 약 1년 전, 저를 포함한 3명이 javascript 스터디를 할 때에, 한 친구가 async의 내부 구현에 대해 궁금증을 가지고 뜯어보기로 합니다. async는 내부적으로 어떻게 구현될까요? 1년 전 스터디를 토대로, async는 내부적으로 어떻게 구현되는지 살펴봅시다.

먼저 저는 이제 javascript는 모르고 typescript만 아는 개발자이기 때문에(농담입니다.) typescript를 ES5 문법으로 바꾸어 보겠습니다. 참고로 typescript는 javascript로 변환되고, 만약 브라우저가 해당 버전의 javascript가 지원되지 않는다면 ES5 등의 구버전 문법으로 변환됩니다. 즉, 저희는 ES5 문법으로 async, await에 대해 살펴보는 것입니다. [타입스크립트 to ES5 변환 사이트](https://www.typescriptlang.org/play)에 접속한 뒤, TS Config 탭을 클릭하여 Target 버전을 선택하면 손쉽게 변환이 가능합니다. 아래는 변환 전 코드입니다.

```typescript
async function fetchData(): Promise<any> {
  const response = await fetch("https://j93.es");
  return response.json();
}
fetchData().then(console.log);
```

그리고 다음은 변환 후 코드의 일부입니다.

```javascript
"use strict";
/* 생략 */
function fetchData() {
  return __awaiter(this, void 0, void 0, function () {
    var response;
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          // 1) fetch 호출
          return [
            4 /*yield*/,
            fetch("https://jsonplaceholder.typicode.com/todos/1"),
          ];
        case 1:
          // 2) 응답을 받아서 response 변수에 저장
          response = _a.sent();
          // 3) response.json() 결과(실제 데이터) 반환
          return [2 /*return*/, response.json()];
      }
    });
  });
}
/* 생략 */
```

\_\_generator와 \_\_awaiter는 코드가 복잡하기에 코드 첨부를 생략하고, 간단한 설명을 제시해보겠습니다. \_\_generator는 State Machine을 활용하여 비동기에 대한 실질적인 로직을 처리하는 함수입니다. 다음으로 \_\_awaiter는 \_\_generator를 이용하여 fetch 등의 비동기 함수를 Promise로 동작시키는 함수입니다. 위의 코드를 분석해보면 http 요청을 0번 상태에서 기다리다가, 1번 상태에서 response를 반환합니다.

이때 State Machine을 활용하지 않았다면, 0번 상태에서 while문을 순회하며 fetch 요청 응답을 기다려야할 것입니다. 이렇게 구현했다면 javascript는 싱글 스레드로 동작하기 때문에, while 문을 순회하며 fetch 함수의 응답을 기다리는 동안에는 다른 작업을 수행하지 못할 것입니다. 이는 굉장한 자원낭비일 것입니다. 하지만 State Machine을 활용하여 상태를 저장해둔다면, 비동기 함수를 중지하고 다른 작업을 수행할 수 있습니다. 원활한 이해를 위하여 아래에 간단하게 State Machine 활용 여부에 따른 작업처리 순서를 적어보겠습니다.

- while문으로 block 시 작업처리 순서

  1. fetch 요청 시작
  2. while문으로 응답 대기
  3. fetch 응답 반환
  4. 다른 작업 수행

- State Machine 활용 시 작업처리 순서

  1. fetch 요청 시작
  2. 0번 상태에서 응답 대기
  3. 다른 작업 수행
  4. 0번 상태에서 응답 대기
  5. 다른 작업 수행
  6. 1번 상태에서 fetch 응답 반환

즉, State Machine을 통하여, 비동기 연산이 완료될 때까지 다른 작업을 멈추고 기다리는 것이 아닌, 하나의 비동기 함수를 중단하고 다시 재개하며, 멀티 스레드"처럼" 작업을 처리할 수 있습니다. (다만, 이 예시에는 State Machine을 활용하지 않는다면 while 문으로 blocking 해야한다는 다소 극단적인 전제가 있습니다. 하지만 큰 틀에서 이해하기에는 무리가 없다고 판단하기에 해당 예시를 사용하였음을 밝힙니다.)

javascript와 임베디드 소프트웨어는 모두 연산의 최적화가 필요하며, 여러 작업을 함께 처리해야하고, 대부분 싱글 스레드 환경에서 동작합니다. 이러한 공통된 문제 상황으로 인하여 State Machine이 낮은 레벨, 높은 레벨에서 두루 사용되는 것일지도 모르겠습니다.이렇게 임베디드 소프트웨어를 통하여 학습한 State Machine을 바탕으로, 기존에는 추상적으로 인지하였던 비동기 개념에 대해 조금더 깊은 지식을 얻었던 경험을 소개해봤습니다.

## 6. 나오며

지금까지 STEP 라인트레이서를 소개하고, 모듈화, 성능 향상과 테스트, 의존성 주입, State Machine과 비동기 함수 등을 소주제로 저의 인사이트를 공유해보았습니다. 저의 경우, 임베디드 소프트웨어에서 배운점이, 높은 레벨의 개발을 더욱 깊게 이해할 수 있는 밑거름으로 작용한 것 같습니다. STEP 라인트레이서는, 제가 개발을 시작하고 처음으로 대회에 나가 평가받은 프로젝트여서, 특별한 애착이 있는 것 같습니다. 이러한 STEP 라인트레이서를 소개하고, 관련한 저의 통찰을 소개할 수 있어서 영광입니다. 이만 글을 줄여보겠습니다.
